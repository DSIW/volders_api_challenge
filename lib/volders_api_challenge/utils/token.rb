# Token is a base64 encoded token containing identifier and secret.
class Token
  # Separator for identifier and secret
  SEPARATOR = ':'

  # Check the secret. The secret contains the public
  # user id and the user secret separated by ":".
  def initialize(base64_token)
    @base64_token = base64_token
  end

  # Generate a new base64 encoded token based on identifier and secret length
  #
  # The token contains 'IDENTIFIER:SECRET'.
  #
  # @return [Token] base64 encoded token
  #
  # @example
  #   Token.generate(1, 32) #=> #<Token:0x00559bf90913f8 @base64_token="MTo3MmRmMDc4M2RlZjhlMTEzZjU2ZDgyMjVkYTY5MjU0MQ">
  def self.generate(identifier, secret_length)
    identifier = identifier.to_s

    if identifier.include? SEPARATOR
      raise ArgumentError, 'identifier must not contain ":"'
    end

    if secret_length % 2 == 1
      raise ArgumentError, 'secret_length must be even'
    end

    secret = SecureRandom.hex(secret_length / 2)
    token = [identifier, secret].join(SEPARATOR)
    base64_token = Base64.encode64(token).sub(/=+$/, '').gsub("\n", '')
    new(base64_token)
  end

  # Returns identifier
  #
  # @return [String] identifier
  def identifier
    decoded.split(SEPARATOR)[0]
  end

  # Check the secret. The secret contains the public
  # user id and the user secret separated by ":".
  #
  # This method uses constant time string comparison by `secure_compare` to be
  # secure against Timing Attacks (see
  # https://thisdata.com/blog/timing-attacks-against-string-comparison/).
  #
  # @param real_token [String] token generated by `generate`
  # @return [Boolean] true if secrets are the same, otherwise false.
  #
  # @example
  #   encoded = Base64.encode64(['1', 'secret'].join(':'))
  #   Token.new(encoded).check("secret") #=> true
  #   encoded = Base64.encode64(['1', 'wrong_secret'].join(':'))
  #   Token.new(encoded).check("secret") #=> false
  def check(real_secret)
    # NOTE: the values compared should be of fixed length
    Rack::Utils.secure_compare(sha256(secret), sha256(real_secret))
  end

  def base64_encoded
    @base64_token
  end

  private

  def secret
    decoded.split(SEPARATOR)[1]
  end

  def decoded
    Base64.decode64(@base64_token)
  end

  def sha256(string)
    Digest::SHA256.hexdigest(string.to_s)
  end
end
