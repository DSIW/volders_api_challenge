module TokenUtils
  SEPARATOR = ':'

  # Generate base64 encoded token based on identifier and secret length
  #
  # The token contains 'identifier:secret...'
  #
  # @return token [String] base64 encoded token
  #
  # @example
  #   TokenUtils.generate(1, 32) #=> "MTprYmFrc3Z3anZ0dmkxdjI0b2l2YzVvYzFrYzF4amFm"
  def generate(identifier, secret_length)
    identifier = identifier.to_s

    if identifier.include? SEPARATOR
      raise ArgumentError, 'identifier must not contain ":"'
    end

    if secret_length % 2 == 1
      raise ArgumentError, 'secret_length must be even'
    end

    secret = SecureRandom.hex(secret_length / 2)
    Base64.encode64([identifier, secret].join(SEPARATOR)).gsub("\n", '')
  end
  module_function :generate

  # Check the base64 encoded token to be correct. The token contains the public
  # user id and the user secret separated by ":".
  #
  # This method uses constant time string comparison by `secure_compare` to be
  # secure against Timing Attacks (see
  # https://thisdata.com/blog/timing-attacks-against-string-comparison/).
  #
  # @param base64_token [String] base64 encoded token generated by `generate`
  # @yieldparam [String] identifier used to get the secret
  # @yieldreturn [String] secret for the identifier
  # @return [Boolean] true if secrets are the same, otherwise false.
  #
  # @example
  #   correct = TimeUtils.check("abc123") do |user_id|
  #     UserRepository.new.find(user_id).token
  #   end
  def check(base64_token)
    decoded = Base64.decode64(base64_token)
    identifier, secret = decoded.split(SEPARATOR)

    real_secret = yield(identifier)

    # NOTE: the values compared should be of fixed length
    secret_sha256 = Digest::SHA256.hexdigest(secret.to_s)
    real_secret_sha256 = Digest::SHA256.hexdigest(real_secret.to_s)
    Rack::Utils.secure_compare(secret_sha256, real_secret_sha256)
  end
  module_function :check
end
